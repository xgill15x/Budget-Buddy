{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar _t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n  isTSTypeAnnotation,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/jason/OneDrive/desktop/BudgetTracker/react/node_modules/@babel/traverse/lib/path/inference/inferers.js"],"names":["Object","defineProperty","exports","value","VariableDeclarator","TypeCastExpression","NewExpression","TemplateLiteral","UnaryExpression","BinaryExpression","LogicalExpression","ConditionalExpression","SequenceExpression","ParenthesizedExpression","AssignmentExpression","UpdateExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","RegExpLiteral","ObjectExpression","ArrayExpression","RestElement","ClassDeclaration","ClassExpression","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","Func","CallExpression","TaggedTemplateExpression","enumerable","get","_infererReference","default","_t","require","BOOLEAN_BINARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","NUMBER_BINARY_OPERATORS","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","anyTypeAnnotation","arrayTypeAnnotation","booleanTypeAnnotation","buildMatchMemberExpression","createFlowUnionType","createTSUnionType","createUnionTypeAnnotation","genericTypeAnnotation","identifier","isTSTypeAnnotation","nullLiteralTypeAnnotation","numberTypeAnnotation","stringTypeAnnotation","tupleTypeAnnotation","unionTypeAnnotation","voidTypeAnnotation","_type","id","isIdentifier","init","type","getTypeAnnotation","isCallExpression","name","scope","hasBinding","node","typeAnnotation","validParent","callee","operator","indexOf","right","left","isBaseType","argumentTypes","pop","isArrayFrom","isObjectKeys","isObjectValues","isObjectEntries","resolveCall","resolve","isFunction","is","returnType"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar _t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n  isTSTypeAnnotation,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}"]},"metadata":{},"sourceType":"script"}