{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isBinding,\n  isBlockScoped,\n  isExportDeclaration,\n  isExpression,\n  isFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isReferenced,\n  isScope,\n  isStatement,\n  isVar,\n  isVariableDeclaration,\n  react\n} = _t;\nconst {\n  isCompatTag\n} = react;\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n      if (isJSXIdentifier(node, opts)) {\n        if (isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return isMemberExpression(node) && isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return isIdentifier(node) && isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (isStatement(node)) {\n      if (isVariableDeclaration(node)) {\n        if (isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (isFlow(node)) {\n      return true;\n    } else if (isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","map":{"version":3,"sources":["C:/Users/jason/OneDrive/desktop/BudgetTracker/react/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"],"names":["Object","defineProperty","exports","value","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","ReferencedIdentifier","_t","require","isBinding","isBlockScoped","isExportDeclaration","isExpression","isFlow","isForStatement","isForXStatement","isIdentifier","isImportDeclaration","isImportSpecifier","isJSXIdentifier","isJSXMemberExpression","isMemberExpression","isReferenced","isScope","isStatement","isVar","isVariableDeclaration","react","isCompatTag","types","checkPath","path","opts","node","parent","name","parentPath","grandparent","left","init","isReferencedIdentifier","loc","isUser","scope","isPure","importKind","exportKind","isObjectPattern","isObjectExpression","await"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isBinding,\n  isBlockScoped,\n  isExportDeclaration,\n  isExpression,\n  isFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isReferenced,\n  isScope,\n  isStatement,\n  isVar,\n  isVariableDeclaration,\n  react\n} = _t;\nconst {\n  isCompatTag\n} = react;\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n      if (isJSXIdentifier(node, opts)) {\n        if (isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return isMemberExpression(node) && isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return isIdentifier(node) && isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (isStatement(node)) {\n      if (isVariableDeclaration(node)) {\n        if (isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (isFlow(node)) {\n      return true;\n    } else if (isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;"]},"metadata":{},"sourceType":"script"}