{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createPlugin;\n\nvar _pluginSyntaxJsx = require(\"@babel/plugin-syntax-jsx\");\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\"\n};\nconst JSX_SOURCE_ANNOTATION_REGEX = /\\*?\\s*@jsxImportSource\\s+([^\\s]+)/;\nconst JSX_RUNTIME_ANNOTATION_REGEX = /\\*?\\s*@jsxRuntime\\s+([^\\s]+)/;\nconst JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\nconst JSX_FRAG_ANNOTATION_REGEX = /\\*?\\s*@jsxFrag\\s+([^\\s]+)/;\n\nconst get = (pass, name) => pass.get(`@babel/plugin-react-jsx/${name}`);\n\nconst set = (pass, name, v) => pass.set(`@babel/plugin-react-jsx/${name}`, v);\n\nfunction createPlugin({\n  name,\n  development\n}) {\n  return (0, _helperPluginUtils.declare)((api, options) => {\n    const {\n      pure: PURE_ANNOTATION,\n      throwIfNamespace = true,\n      filter,\n      runtime: RUNTIME_DEFAULT = development ? \"automatic\" : \"classic\",\n      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag\n    } = options;\n    {\n      var {\n        useSpread = false,\n        useBuiltIns = false\n      } = options;\n\n      if (RUNTIME_DEFAULT === \"classic\") {\n        if (typeof useSpread !== \"boolean\") {\n          throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useSpread (defaults to false)\");\n        }\n\n        if (typeof useBuiltIns !== \"boolean\") {\n          throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useBuiltIns (defaults to false)\");\n        }\n\n        if (useSpread && useBuiltIns) {\n          throw new Error(\"transform-react-jsx currently only accepts useBuiltIns or useSpread \" + \"but not both\");\n        }\n      }\n    }\n    const injectMetaPropertiesVisitor = {\n      JSXOpeningElement(path, state) {\n        for (const attr of path.get(\"attributes\")) {\n          if (!attr.isJSXElement()) continue;\n          const {\n            name\n          } = attr.node.name;\n\n          if (name === \"__source\" || name === \"__self\") {\n            throw path.buildCodeFrameError(`__source and __self should not be defined in props and are reserved for internal usage.`);\n          }\n        }\n\n        const attributes = [];\n\n        if (isThisAllowed(path)) {\n          attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(\"__self\"), _core.types.jsxExpressionContainer(_core.types.thisExpression())));\n        }\n\n        attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(\"__source\"), _core.types.jsxExpressionContainer(makeSource(path, state))));\n        path.pushContainer(\"attributes\", attributes);\n      }\n\n    };\n    return {\n      name,\n      inherits: _pluginSyntaxJsx.default,\n      visitor: {\n        JSXNamespacedName(path) {\n          if (throwIfNamespace) {\n            throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`);\n          }\n        },\n\n        JSXSpreadChild(path) {\n          throw path.buildCodeFrameError(\"Spread children are not supported in React.\");\n        },\n\n        Program: {\n          enter(path, state) {\n            const {\n              file\n            } = state;\n            let runtime = RUNTIME_DEFAULT;\n            let source = IMPORT_SOURCE_DEFAULT;\n            let pragma = PRAGMA_DEFAULT;\n            let pragmaFrag = PRAGMA_FRAG_DEFAULT;\n            let sourceSet = !!options.importSource;\n            let pragmaSet = !!options.pragma;\n            let pragmaFragSet = !!options.pragmaFrag;\n\n            if (file.ast.comments) {\n              for (const comment of file.ast.comments) {\n                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);\n\n                if (sourceMatches) {\n                  source = sourceMatches[1];\n                  sourceSet = true;\n                }\n\n                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);\n\n                if (runtimeMatches) {\n                  runtime = runtimeMatches[1];\n                }\n\n                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n                if (jsxMatches) {\n                  pragma = jsxMatches[1];\n                  pragmaSet = true;\n                }\n\n                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\n\n                if (jsxFragMatches) {\n                  pragmaFrag = jsxFragMatches[1];\n                  pragmaFragSet = true;\n                }\n              }\n            }\n\n            set(state, \"runtime\", runtime);\n\n            if (runtime === \"classic\") {\n              if (sourceSet) {\n                throw path.buildCodeFrameError(`importSource cannot be set when runtime is classic.`);\n              }\n\n              const createElement = toMemberExpression(pragma);\n              const fragment = toMemberExpression(pragmaFrag);\n              set(state, \"id/createElement\", () => _core.types.cloneNode(createElement));\n              set(state, \"id/fragment\", () => _core.types.cloneNode(fragment));\n              set(state, \"defaultPure\", pragma === DEFAULT.pragma);\n            } else if (runtime === \"automatic\") {\n              if (pragmaSet || pragmaFragSet) {\n                throw path.buildCodeFrameError(`pragma and pragmaFrag cannot be set when runtime is automatic.`);\n              }\n\n              const define = (name, id) => set(state, name, createImportLazily(state, path, id, source));\n\n              define(\"id/jsx\", development ? \"jsxDEV\" : \"jsx\");\n              define(\"id/jsxs\", development ? \"jsxDEV\" : \"jsxs\");\n              define(\"id/createElement\", \"createElement\");\n              define(\"id/fragment\", \"Fragment\");\n              set(state, \"defaultPure\", source === DEFAULT.importSource);\n            } else {\n              throw path.buildCodeFrameError(`Runtime must be either \"classic\" or \"automatic\".`);\n            }\n\n            if (development) {\n              path.traverse(injectMetaPropertiesVisitor, state);\n            }\n          }\n\n        },\n        JSXElement: {\n          exit(path, file) {\n            let callExpr;\n\n            if (get(file, \"runtime\") === \"classic\" || shouldUseCreateElement(path)) {\n              callExpr = buildCreateElementCall(path, file);\n            } else {\n              callExpr = buildJSXElementCall(path, file);\n            }\n\n            path.replaceWith(_core.types.inherits(callExpr, path.node));\n          }\n\n        },\n        JSXFragment: {\n          exit(path, file) {\n            let callExpr;\n\n            if (get(file, \"runtime\") === \"classic\") {\n              callExpr = buildCreateElementFragmentCall(path, file);\n            } else {\n              callExpr = buildJSXFragmentCall(path, file);\n            }\n\n            path.replaceWith(_core.types.inherits(callExpr, path.node));\n          }\n\n        },\n\n        JSXAttribute(path) {\n          if (_core.types.isJSXElement(path.node.value)) {\n            path.node.value = _core.types.jsxExpressionContainer(path.node.value);\n          }\n        }\n\n      }\n    };\n\n    function getThisFunctionParent(path) {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunctionParent() && !scope.path.isArrowFunctionExpression()) {\n          return scope.path;\n        }\n      } while (scope = scope.parent);\n\n      return null;\n    }\n\n    function isDerivedClass(classPath) {\n      return classPath.node.superClass !== null;\n    }\n\n    function isThisAllowed(path) {\n      const parentMethodOrFunction = getThisFunctionParent(path);\n\n      if (parentMethodOrFunction === null) {\n        return true;\n      }\n\n      if (!parentMethodOrFunction.isMethod()) {\n        return true;\n      }\n\n      if (parentMethodOrFunction.node.kind !== \"constructor\") {\n        return true;\n      }\n\n      return !isDerivedClass(parentMethodOrFunction.parentPath.parentPath);\n    }\n\n    function call(pass, name, args) {\n      const node = _core.types.callExpression(get(pass, `id/${name}`)(), args);\n\n      if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get(pass, \"defaultPure\")) (0, _helperAnnotateAsPure.default)(node);\n      return node;\n    }\n\n    function shouldUseCreateElement(path) {\n      const openingPath = path.get(\"openingElement\");\n      const attributes = openingPath.node.attributes;\n      let seenPropsSpread = false;\n\n      for (let i = 0; i < attributes.length; i++) {\n        const attr = attributes[i];\n\n        if (seenPropsSpread && _core.types.isJSXAttribute(attr) && attr.name.name === \"key\") {\n          return true;\n        } else if (_core.types.isJSXSpreadAttribute(attr)) {\n          seenPropsSpread = true;\n        }\n      }\n\n      return false;\n    }\n\n    function convertJSXIdentifier(node, parent) {\n      if (_core.types.isJSXIdentifier(node)) {\n        if (node.name === \"this\" && _core.types.isReferenced(node, parent)) {\n          return _core.types.thisExpression();\n        } else if (_core.types.isValidIdentifier(node.name, false)) {\n          node.type = \"Identifier\";\n        } else {\n          return _core.types.stringLiteral(node.name);\n        }\n      } else if (_core.types.isJSXMemberExpression(node)) {\n        return _core.types.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));\n      } else if (_core.types.isJSXNamespacedName(node)) {\n        return _core.types.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n      }\n\n      return node;\n    }\n\n    function convertAttributeValue(node) {\n      if (_core.types.isJSXExpressionContainer(node)) {\n        return node.expression;\n      } else {\n        return node;\n      }\n    }\n\n    function accumulateAttribute(array, attribute) {\n      if (_core.types.isJSXSpreadAttribute(attribute.node)) {\n        const arg = attribute.node.argument;\n\n        if (_core.types.isObjectExpression(arg)) {\n          array.push(...arg.properties);\n        } else {\n          array.push(_core.types.spreadElement(arg));\n        }\n\n        return array;\n      }\n\n      const value = convertAttributeValue(attribute.node.name.name !== \"key\" ? attribute.node.value || _core.types.booleanLiteral(true) : attribute.node.value);\n\n      if (attribute.node.name.name === \"key\" && value === null) {\n        throw attribute.buildCodeFrameError('Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.');\n      }\n\n      if (_core.types.isStringLiteral(value) && !_core.types.isJSXExpressionContainer(attribute.node.value)) {\n        var _value$extra;\n\n        value.value = value.value.replace(/\\n\\s+/g, \" \");\n        (_value$extra = value.extra) == null ? true : delete _value$extra.raw;\n      }\n\n      if (_core.types.isJSXNamespacedName(attribute.node.name)) {\n        attribute.node.name = _core.types.stringLiteral(attribute.node.name.namespace.name + \":\" + attribute.node.name.name.name);\n      } else if (_core.types.isValidIdentifier(attribute.node.name.name, false)) {\n        attribute.node.name.type = \"Identifier\";\n      } else {\n        attribute.node.name = _core.types.stringLiteral(attribute.node.name.name);\n      }\n\n      array.push(_core.types.inherits(_core.types.objectProperty(attribute.node.name, value), attribute.node));\n      return array;\n    }\n\n    function buildChildrenProperty(children) {\n      let childrenNode;\n\n      if (children.length === 1) {\n        childrenNode = children[0];\n      } else if (children.length > 1) {\n        childrenNode = _core.types.arrayExpression(children);\n      } else {\n        return undefined;\n      }\n\n      return _core.types.objectProperty(_core.types.identifier(\"children\"), childrenNode);\n    }\n\n    function buildJSXElementCall(path, file) {\n      const openingPath = path.get(\"openingElement\");\n      const args = [getTag(openingPath)];\n      const attribsArray = [];\n      const extracted = Object.create(null);\n\n      for (const attr of openingPath.get(\"attributes\")) {\n        if (attr.isJSXAttribute() && _core.types.isJSXIdentifier(attr.node.name)) {\n          const {\n            name\n          } = attr.node.name;\n\n          switch (name) {\n            case \"__source\":\n            case \"__self\":\n              if (extracted[name]) throw sourceSelfError(path, name);\n\n            case \"key\":\n              {\n                const keyValue = convertAttributeValue(attr.node.value);\n\n                if (keyValue === null) {\n                  throw attr.buildCodeFrameError('Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.');\n                }\n\n                extracted[name] = keyValue;\n                break;\n              }\n\n            default:\n              attribsArray.push(attr);\n          }\n        } else {\n          attribsArray.push(attr);\n        }\n      }\n\n      const children = _core.types.react.buildChildren(path.node);\n\n      let attribs;\n\n      if (attribsArray.length || children.length) {\n        attribs = buildJSXOpeningElementAttributes(attribsArray, file, children);\n      } else {\n        attribs = _core.types.objectExpression([]);\n      }\n\n      args.push(attribs);\n\n      if (development) {\n        var _extracted$key, _extracted$__source, _extracted$__self;\n\n        args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : path.scope.buildUndefinedNode());\n      } else if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    function buildJSXOpeningElementAttributes(attribs, file, children) {\n      const props = attribs.reduce(accumulateAttribute, []);\n\n      if ((children == null ? void 0 : children.length) > 0) {\n        props.push(buildChildrenProperty(children));\n      }\n\n      return _core.types.objectExpression(props);\n    }\n\n    function buildJSXFragmentCall(path, file) {\n      const args = [get(file, \"id/fragment\")()];\n\n      const children = _core.types.react.buildChildren(path.node);\n\n      args.push(_core.types.objectExpression(children.length > 0 ? [buildChildrenProperty(children)] : []));\n\n      if (development) {\n        args.push(path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1));\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    function buildCreateElementFragmentCall(path, file) {\n      if (filter && !filter(path.node, file)) return;\n      return call(file, \"createElement\", [get(file, \"id/fragment\")(), _core.types.nullLiteral(), ..._core.types.react.buildChildren(path.node)]);\n    }\n\n    function buildCreateElementCall(path, file) {\n      const openingPath = path.get(\"openingElement\");\n      return call(file, \"createElement\", [getTag(openingPath), buildCreateElementOpeningElementAttributes(file, path, openingPath.get(\"attributes\")), ..._core.types.react.buildChildren(path.node)]);\n    }\n\n    function getTag(openingPath) {\n      const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n      let tagName;\n\n      if (_core.types.isIdentifier(tagExpr)) {\n        tagName = tagExpr.name;\n      } else if (_core.types.isLiteral(tagExpr)) {\n        tagName = tagExpr.value;\n      }\n\n      if (_core.types.react.isCompatTag(tagName)) {\n        return _core.types.stringLiteral(tagName);\n      } else {\n        return tagExpr;\n      }\n    }\n\n    function buildCreateElementOpeningElementAttributes(file, path, attribs) {\n      const runtime = get(file, \"runtime\");\n      {\n        if (runtime !== \"automatic\") {\n          const objs = [];\n          const props = attribs.reduce(accumulateAttribute, []);\n\n          if (!useSpread) {\n            let start = 0;\n            props.forEach((prop, i) => {\n              if (_core.types.isSpreadElement(prop)) {\n                if (i > start) {\n                  objs.push(_core.types.objectExpression(props.slice(start, i)));\n                }\n\n                objs.push(prop.argument);\n                start = i + 1;\n              }\n            });\n\n            if (props.length > start) {\n              objs.push(_core.types.objectExpression(props.slice(start)));\n            }\n          } else if (props.length) {\n            objs.push(_core.types.objectExpression(props));\n          }\n\n          if (!objs.length) {\n            return _core.types.nullLiteral();\n          }\n\n          if (objs.length === 1) {\n            return objs[0];\n          }\n\n          if (!_core.types.isObjectExpression(objs[0])) {\n            objs.unshift(_core.types.objectExpression([]));\n          }\n\n          const helper = useBuiltIns ? _core.types.memberExpression(_core.types.identifier(\"Object\"), _core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n          return _core.types.callExpression(helper, objs);\n        }\n      }\n      const props = [];\n      const found = Object.create(null);\n\n      for (const attr of attribs) {\n        const name = _core.types.isJSXAttribute(attr) && _core.types.isJSXIdentifier(attr.name) && attr.name.name;\n\n        if (runtime === \"automatic\" && (name === \"__source\" || name === \"__self\")) {\n          if (found[name]) throw sourceSelfError(path, name);\n          found[name] = true;\n        }\n\n        accumulateAttribute(props, attr);\n      }\n\n      return props.length === 1 && _core.types.isSpreadElement(props[0]) ? props[0].argument : props.length > 0 ? _core.types.objectExpression(props) : _core.types.nullLiteral();\n    }\n  });\n\n  function getSource(source, importName) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function createImportLazily(pass, path, importName, source) {\n    return () => {\n      const actualSource = getSource(source, importName);\n\n      if ((0, _helperModuleImports.isModule)(path)) {\n        let reference = get(pass, `imports/${importName}`);\n        if (reference) return _core.types.cloneNode(reference);\n        reference = (0, _helperModuleImports.addNamed)(path, importName, actualSource, {\n          importedInterop: \"uncompiled\",\n          importPosition: \"after\"\n        });\n        set(pass, `imports/${importName}`, reference);\n        return reference;\n      } else {\n        let reference = get(pass, `requires/${actualSource}`);\n\n        if (reference) {\n          reference = _core.types.cloneNode(reference);\n        } else {\n          reference = (0, _helperModuleImports.addNamespace)(path, actualSource, {\n            importedInterop: \"uncompiled\"\n          });\n          set(pass, `requires/${actualSource}`, reference);\n        }\n\n        return _core.types.memberExpression(reference, _core.types.identifier(importName));\n      }\n    };\n  }\n}\n\nfunction toMemberExpression(id) {\n  return id.split(\".\").map(name => _core.types.identifier(name)).reduce((object, property) => _core.types.memberExpression(object, property));\n}\n\nfunction makeSource(path, state) {\n  const location = path.node.loc;\n\n  if (!location) {\n    return path.scope.buildUndefinedNode();\n  }\n\n  if (!state.fileNameIdentifier) {\n    const {\n      filename = \"\"\n    } = state;\n    const fileNameIdentifier = path.scope.generateUidIdentifier(\"_jsxFileName\");\n    const scope = path.hub.getScope();\n\n    if (scope) {\n      scope.push({\n        id: fileNameIdentifier,\n        init: _core.types.stringLiteral(filename)\n      });\n    }\n\n    state.fileNameIdentifier = fileNameIdentifier;\n  }\n\n  return makeTrace(_core.types.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);\n}\n\nfunction makeTrace(fileNameIdentifier, lineNumber, column0Based) {\n  const fileLineLiteral = lineNumber != null ? _core.types.numericLiteral(lineNumber) : _core.types.nullLiteral();\n  const fileColumnLiteral = column0Based != null ? _core.types.numericLiteral(column0Based + 1) : _core.types.nullLiteral();\n\n  const fileNameProperty = _core.types.objectProperty(_core.types.identifier(\"fileName\"), fileNameIdentifier);\n\n  const lineNumberProperty = _core.types.objectProperty(_core.types.identifier(\"lineNumber\"), fileLineLiteral);\n\n  const columnNumberProperty = _core.types.objectProperty(_core.types.identifier(\"columnNumber\"), fileColumnLiteral);\n\n  return _core.types.objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);\n}\n\nfunction sourceSelfError(path, name) {\n  const pluginName = `transform-react-jsx-${name.slice(2)}`;\n  return path.buildCodeFrameError(`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`);\n}","map":{"version":3,"sources":["C:/Users/jason/OneDrive/desktop/BudgetTracker/react/node_modules/@babel/plugin-transform-react-jsx/lib/create-plugin.js"],"names":["Object","defineProperty","exports","value","default","createPlugin","_pluginSyntaxJsx","require","_helperPluginUtils","_core","_helperModuleImports","_helperAnnotateAsPure","DEFAULT","importSource","runtime","pragma","pragmaFrag","JSX_SOURCE_ANNOTATION_REGEX","JSX_RUNTIME_ANNOTATION_REGEX","JSX_ANNOTATION_REGEX","JSX_FRAG_ANNOTATION_REGEX","get","pass","name","set","v","development","declare","api","options","pure","PURE_ANNOTATION","throwIfNamespace","filter","RUNTIME_DEFAULT","IMPORT_SOURCE_DEFAULT","PRAGMA_DEFAULT","PRAGMA_FRAG_DEFAULT","useSpread","useBuiltIns","Error","injectMetaPropertiesVisitor","JSXOpeningElement","path","state","attr","isJSXElement","node","buildCodeFrameError","attributes","isThisAllowed","push","types","jsxAttribute","jsxIdentifier","jsxExpressionContainer","thisExpression","makeSource","pushContainer","inherits","visitor","JSXNamespacedName","JSXSpreadChild","Program","enter","file","source","sourceSet","pragmaSet","pragmaFragSet","ast","comments","comment","sourceMatches","exec","runtimeMatches","jsxMatches","jsxFragMatches","createElement","toMemberExpression","fragment","cloneNode","define","id","createImportLazily","traverse","JSXElement","exit","callExpr","shouldUseCreateElement","buildCreateElementCall","buildJSXElementCall","replaceWith","JSXFragment","buildCreateElementFragmentCall","buildJSXFragmentCall","JSXAttribute","getThisFunctionParent","scope","isFunctionParent","isArrowFunctionExpression","parent","isDerivedClass","classPath","superClass","parentMethodOrFunction","isMethod","kind","parentPath","call","args","callExpression","openingPath","seenPropsSpread","i","length","isJSXAttribute","isJSXSpreadAttribute","convertJSXIdentifier","isJSXIdentifier","isReferenced","isValidIdentifier","type","stringLiteral","isJSXMemberExpression","memberExpression","object","property","isJSXNamespacedName","namespace","convertAttributeValue","isJSXExpressionContainer","expression","accumulateAttribute","array","attribute","arg","argument","isObjectExpression","properties","spreadElement","booleanLiteral","isStringLiteral","_value$extra","replace","extra","raw","objectProperty","buildChildrenProperty","children","childrenNode","arrayExpression","undefined","identifier","getTag","attribsArray","extracted","create","sourceSelfError","keyValue","react","buildChildren","attribs","buildJSXOpeningElementAttributes","objectExpression","_extracted$key","_extracted$__source","_extracted$__self","key","buildUndefinedNode","__source","__self","props","reduce","nullLiteral","buildCreateElementOpeningElementAttributes","tagExpr","tagName","isIdentifier","isLiteral","isCompatTag","objs","start","forEach","prop","isSpreadElement","slice","unshift","helper","addHelper","found","getSource","importName","actualSource","isModule","reference","addNamed","importedInterop","importPosition","addNamespace","split","map","location","loc","fileNameIdentifier","filename","generateUidIdentifier","hub","getScope","init","makeTrace","line","column","lineNumber","column0Based","fileLineLiteral","numericLiteral","fileColumnLiteral","fileNameProperty","lineNumberProperty","columnNumberProperty","pluginName"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createPlugin;\n\nvar _pluginSyntaxJsx = require(\"@babel/plugin-syntax-jsx\");\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\"\n};\nconst JSX_SOURCE_ANNOTATION_REGEX = /\\*?\\s*@jsxImportSource\\s+([^\\s]+)/;\nconst JSX_RUNTIME_ANNOTATION_REGEX = /\\*?\\s*@jsxRuntime\\s+([^\\s]+)/;\nconst JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\nconst JSX_FRAG_ANNOTATION_REGEX = /\\*?\\s*@jsxFrag\\s+([^\\s]+)/;\n\nconst get = (pass, name) => pass.get(`@babel/plugin-react-jsx/${name}`);\n\nconst set = (pass, name, v) => pass.set(`@babel/plugin-react-jsx/${name}`, v);\n\nfunction createPlugin({\n  name,\n  development\n}) {\n  return (0, _helperPluginUtils.declare)((api, options) => {\n    const {\n      pure: PURE_ANNOTATION,\n      throwIfNamespace = true,\n      filter,\n      runtime: RUNTIME_DEFAULT = development ? \"automatic\" : \"classic\",\n      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag\n    } = options;\n    {\n      var {\n        useSpread = false,\n        useBuiltIns = false\n      } = options;\n\n      if (RUNTIME_DEFAULT === \"classic\") {\n        if (typeof useSpread !== \"boolean\") {\n          throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useSpread (defaults to false)\");\n        }\n\n        if (typeof useBuiltIns !== \"boolean\") {\n          throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useBuiltIns (defaults to false)\");\n        }\n\n        if (useSpread && useBuiltIns) {\n          throw new Error(\"transform-react-jsx currently only accepts useBuiltIns or useSpread \" + \"but not both\");\n        }\n      }\n    }\n    const injectMetaPropertiesVisitor = {\n      JSXOpeningElement(path, state) {\n        for (const attr of path.get(\"attributes\")) {\n          if (!attr.isJSXElement()) continue;\n          const {\n            name\n          } = attr.node.name;\n\n          if (name === \"__source\" || name === \"__self\") {\n            throw path.buildCodeFrameError(`__source and __self should not be defined in props and are reserved for internal usage.`);\n          }\n        }\n\n        const attributes = [];\n\n        if (isThisAllowed(path)) {\n          attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(\"__self\"), _core.types.jsxExpressionContainer(_core.types.thisExpression())));\n        }\n\n        attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(\"__source\"), _core.types.jsxExpressionContainer(makeSource(path, state))));\n        path.pushContainer(\"attributes\", attributes);\n      }\n\n    };\n    return {\n      name,\n      inherits: _pluginSyntaxJsx.default,\n      visitor: {\n        JSXNamespacedName(path) {\n          if (throwIfNamespace) {\n            throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`);\n          }\n        },\n\n        JSXSpreadChild(path) {\n          throw path.buildCodeFrameError(\"Spread children are not supported in React.\");\n        },\n\n        Program: {\n          enter(path, state) {\n            const {\n              file\n            } = state;\n            let runtime = RUNTIME_DEFAULT;\n            let source = IMPORT_SOURCE_DEFAULT;\n            let pragma = PRAGMA_DEFAULT;\n            let pragmaFrag = PRAGMA_FRAG_DEFAULT;\n            let sourceSet = !!options.importSource;\n            let pragmaSet = !!options.pragma;\n            let pragmaFragSet = !!options.pragmaFrag;\n\n            if (file.ast.comments) {\n              for (const comment of file.ast.comments) {\n                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);\n\n                if (sourceMatches) {\n                  source = sourceMatches[1];\n                  sourceSet = true;\n                }\n\n                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);\n\n                if (runtimeMatches) {\n                  runtime = runtimeMatches[1];\n                }\n\n                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n                if (jsxMatches) {\n                  pragma = jsxMatches[1];\n                  pragmaSet = true;\n                }\n\n                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\n\n                if (jsxFragMatches) {\n                  pragmaFrag = jsxFragMatches[1];\n                  pragmaFragSet = true;\n                }\n              }\n            }\n\n            set(state, \"runtime\", runtime);\n\n            if (runtime === \"classic\") {\n              if (sourceSet) {\n                throw path.buildCodeFrameError(`importSource cannot be set when runtime is classic.`);\n              }\n\n              const createElement = toMemberExpression(pragma);\n              const fragment = toMemberExpression(pragmaFrag);\n              set(state, \"id/createElement\", () => _core.types.cloneNode(createElement));\n              set(state, \"id/fragment\", () => _core.types.cloneNode(fragment));\n              set(state, \"defaultPure\", pragma === DEFAULT.pragma);\n            } else if (runtime === \"automatic\") {\n              if (pragmaSet || pragmaFragSet) {\n                throw path.buildCodeFrameError(`pragma and pragmaFrag cannot be set when runtime is automatic.`);\n              }\n\n              const define = (name, id) => set(state, name, createImportLazily(state, path, id, source));\n\n              define(\"id/jsx\", development ? \"jsxDEV\" : \"jsx\");\n              define(\"id/jsxs\", development ? \"jsxDEV\" : \"jsxs\");\n              define(\"id/createElement\", \"createElement\");\n              define(\"id/fragment\", \"Fragment\");\n              set(state, \"defaultPure\", source === DEFAULT.importSource);\n            } else {\n              throw path.buildCodeFrameError(`Runtime must be either \"classic\" or \"automatic\".`);\n            }\n\n            if (development) {\n              path.traverse(injectMetaPropertiesVisitor, state);\n            }\n          }\n\n        },\n        JSXElement: {\n          exit(path, file) {\n            let callExpr;\n\n            if (get(file, \"runtime\") === \"classic\" || shouldUseCreateElement(path)) {\n              callExpr = buildCreateElementCall(path, file);\n            } else {\n              callExpr = buildJSXElementCall(path, file);\n            }\n\n            path.replaceWith(_core.types.inherits(callExpr, path.node));\n          }\n\n        },\n        JSXFragment: {\n          exit(path, file) {\n            let callExpr;\n\n            if (get(file, \"runtime\") === \"classic\") {\n              callExpr = buildCreateElementFragmentCall(path, file);\n            } else {\n              callExpr = buildJSXFragmentCall(path, file);\n            }\n\n            path.replaceWith(_core.types.inherits(callExpr, path.node));\n          }\n\n        },\n\n        JSXAttribute(path) {\n          if (_core.types.isJSXElement(path.node.value)) {\n            path.node.value = _core.types.jsxExpressionContainer(path.node.value);\n          }\n        }\n\n      }\n    };\n\n    function getThisFunctionParent(path) {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunctionParent() && !scope.path.isArrowFunctionExpression()) {\n          return scope.path;\n        }\n      } while (scope = scope.parent);\n\n      return null;\n    }\n\n    function isDerivedClass(classPath) {\n      return classPath.node.superClass !== null;\n    }\n\n    function isThisAllowed(path) {\n      const parentMethodOrFunction = getThisFunctionParent(path);\n\n      if (parentMethodOrFunction === null) {\n        return true;\n      }\n\n      if (!parentMethodOrFunction.isMethod()) {\n        return true;\n      }\n\n      if (parentMethodOrFunction.node.kind !== \"constructor\") {\n        return true;\n      }\n\n      return !isDerivedClass(parentMethodOrFunction.parentPath.parentPath);\n    }\n\n    function call(pass, name, args) {\n      const node = _core.types.callExpression(get(pass, `id/${name}`)(), args);\n\n      if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get(pass, \"defaultPure\")) (0, _helperAnnotateAsPure.default)(node);\n      return node;\n    }\n\n    function shouldUseCreateElement(path) {\n      const openingPath = path.get(\"openingElement\");\n      const attributes = openingPath.node.attributes;\n      let seenPropsSpread = false;\n\n      for (let i = 0; i < attributes.length; i++) {\n        const attr = attributes[i];\n\n        if (seenPropsSpread && _core.types.isJSXAttribute(attr) && attr.name.name === \"key\") {\n          return true;\n        } else if (_core.types.isJSXSpreadAttribute(attr)) {\n          seenPropsSpread = true;\n        }\n      }\n\n      return false;\n    }\n\n    function convertJSXIdentifier(node, parent) {\n      if (_core.types.isJSXIdentifier(node)) {\n        if (node.name === \"this\" && _core.types.isReferenced(node, parent)) {\n          return _core.types.thisExpression();\n        } else if (_core.types.isValidIdentifier(node.name, false)) {\n          node.type = \"Identifier\";\n        } else {\n          return _core.types.stringLiteral(node.name);\n        }\n      } else if (_core.types.isJSXMemberExpression(node)) {\n        return _core.types.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));\n      } else if (_core.types.isJSXNamespacedName(node)) {\n        return _core.types.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n      }\n\n      return node;\n    }\n\n    function convertAttributeValue(node) {\n      if (_core.types.isJSXExpressionContainer(node)) {\n        return node.expression;\n      } else {\n        return node;\n      }\n    }\n\n    function accumulateAttribute(array, attribute) {\n      if (_core.types.isJSXSpreadAttribute(attribute.node)) {\n        const arg = attribute.node.argument;\n\n        if (_core.types.isObjectExpression(arg)) {\n          array.push(...arg.properties);\n        } else {\n          array.push(_core.types.spreadElement(arg));\n        }\n\n        return array;\n      }\n\n      const value = convertAttributeValue(attribute.node.name.name !== \"key\" ? attribute.node.value || _core.types.booleanLiteral(true) : attribute.node.value);\n\n      if (attribute.node.name.name === \"key\" && value === null) {\n        throw attribute.buildCodeFrameError('Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.');\n      }\n\n      if (_core.types.isStringLiteral(value) && !_core.types.isJSXExpressionContainer(attribute.node.value)) {\n        var _value$extra;\n\n        value.value = value.value.replace(/\\n\\s+/g, \" \");\n        (_value$extra = value.extra) == null ? true : delete _value$extra.raw;\n      }\n\n      if (_core.types.isJSXNamespacedName(attribute.node.name)) {\n        attribute.node.name = _core.types.stringLiteral(attribute.node.name.namespace.name + \":\" + attribute.node.name.name.name);\n      } else if (_core.types.isValidIdentifier(attribute.node.name.name, false)) {\n        attribute.node.name.type = \"Identifier\";\n      } else {\n        attribute.node.name = _core.types.stringLiteral(attribute.node.name.name);\n      }\n\n      array.push(_core.types.inherits(_core.types.objectProperty(attribute.node.name, value), attribute.node));\n      return array;\n    }\n\n    function buildChildrenProperty(children) {\n      let childrenNode;\n\n      if (children.length === 1) {\n        childrenNode = children[0];\n      } else if (children.length > 1) {\n        childrenNode = _core.types.arrayExpression(children);\n      } else {\n        return undefined;\n      }\n\n      return _core.types.objectProperty(_core.types.identifier(\"children\"), childrenNode);\n    }\n\n    function buildJSXElementCall(path, file) {\n      const openingPath = path.get(\"openingElement\");\n      const args = [getTag(openingPath)];\n      const attribsArray = [];\n      const extracted = Object.create(null);\n\n      for (const attr of openingPath.get(\"attributes\")) {\n        if (attr.isJSXAttribute() && _core.types.isJSXIdentifier(attr.node.name)) {\n          const {\n            name\n          } = attr.node.name;\n\n          switch (name) {\n            case \"__source\":\n            case \"__self\":\n              if (extracted[name]) throw sourceSelfError(path, name);\n\n            case \"key\":\n              {\n                const keyValue = convertAttributeValue(attr.node.value);\n\n                if (keyValue === null) {\n                  throw attr.buildCodeFrameError('Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.');\n                }\n\n                extracted[name] = keyValue;\n                break;\n              }\n\n            default:\n              attribsArray.push(attr);\n          }\n        } else {\n          attribsArray.push(attr);\n        }\n      }\n\n      const children = _core.types.react.buildChildren(path.node);\n\n      let attribs;\n\n      if (attribsArray.length || children.length) {\n        attribs = buildJSXOpeningElementAttributes(attribsArray, file, children);\n      } else {\n        attribs = _core.types.objectExpression([]);\n      }\n\n      args.push(attribs);\n\n      if (development) {\n        var _extracted$key, _extracted$__source, _extracted$__self;\n\n        args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : path.scope.buildUndefinedNode());\n      } else if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    function buildJSXOpeningElementAttributes(attribs, file, children) {\n      const props = attribs.reduce(accumulateAttribute, []);\n\n      if ((children == null ? void 0 : children.length) > 0) {\n        props.push(buildChildrenProperty(children));\n      }\n\n      return _core.types.objectExpression(props);\n    }\n\n    function buildJSXFragmentCall(path, file) {\n      const args = [get(file, \"id/fragment\")()];\n\n      const children = _core.types.react.buildChildren(path.node);\n\n      args.push(_core.types.objectExpression(children.length > 0 ? [buildChildrenProperty(children)] : []));\n\n      if (development) {\n        args.push(path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1));\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    function buildCreateElementFragmentCall(path, file) {\n      if (filter && !filter(path.node, file)) return;\n      return call(file, \"createElement\", [get(file, \"id/fragment\")(), _core.types.nullLiteral(), ..._core.types.react.buildChildren(path.node)]);\n    }\n\n    function buildCreateElementCall(path, file) {\n      const openingPath = path.get(\"openingElement\");\n      return call(file, \"createElement\", [getTag(openingPath), buildCreateElementOpeningElementAttributes(file, path, openingPath.get(\"attributes\")), ..._core.types.react.buildChildren(path.node)]);\n    }\n\n    function getTag(openingPath) {\n      const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n      let tagName;\n\n      if (_core.types.isIdentifier(tagExpr)) {\n        tagName = tagExpr.name;\n      } else if (_core.types.isLiteral(tagExpr)) {\n        tagName = tagExpr.value;\n      }\n\n      if (_core.types.react.isCompatTag(tagName)) {\n        return _core.types.stringLiteral(tagName);\n      } else {\n        return tagExpr;\n      }\n    }\n\n    function buildCreateElementOpeningElementAttributes(file, path, attribs) {\n      const runtime = get(file, \"runtime\");\n      {\n        if (runtime !== \"automatic\") {\n          const objs = [];\n          const props = attribs.reduce(accumulateAttribute, []);\n\n          if (!useSpread) {\n            let start = 0;\n            props.forEach((prop, i) => {\n              if (_core.types.isSpreadElement(prop)) {\n                if (i > start) {\n                  objs.push(_core.types.objectExpression(props.slice(start, i)));\n                }\n\n                objs.push(prop.argument);\n                start = i + 1;\n              }\n            });\n\n            if (props.length > start) {\n              objs.push(_core.types.objectExpression(props.slice(start)));\n            }\n          } else if (props.length) {\n            objs.push(_core.types.objectExpression(props));\n          }\n\n          if (!objs.length) {\n            return _core.types.nullLiteral();\n          }\n\n          if (objs.length === 1) {\n            return objs[0];\n          }\n\n          if (!_core.types.isObjectExpression(objs[0])) {\n            objs.unshift(_core.types.objectExpression([]));\n          }\n\n          const helper = useBuiltIns ? _core.types.memberExpression(_core.types.identifier(\"Object\"), _core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n          return _core.types.callExpression(helper, objs);\n        }\n      }\n      const props = [];\n      const found = Object.create(null);\n\n      for (const attr of attribs) {\n        const name = _core.types.isJSXAttribute(attr) && _core.types.isJSXIdentifier(attr.name) && attr.name.name;\n\n        if (runtime === \"automatic\" && (name === \"__source\" || name === \"__self\")) {\n          if (found[name]) throw sourceSelfError(path, name);\n          found[name] = true;\n        }\n\n        accumulateAttribute(props, attr);\n      }\n\n      return props.length === 1 && _core.types.isSpreadElement(props[0]) ? props[0].argument : props.length > 0 ? _core.types.objectExpression(props) : _core.types.nullLiteral();\n    }\n  });\n\n  function getSource(source, importName) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function createImportLazily(pass, path, importName, source) {\n    return () => {\n      const actualSource = getSource(source, importName);\n\n      if ((0, _helperModuleImports.isModule)(path)) {\n        let reference = get(pass, `imports/${importName}`);\n        if (reference) return _core.types.cloneNode(reference);\n        reference = (0, _helperModuleImports.addNamed)(path, importName, actualSource, {\n          importedInterop: \"uncompiled\",\n          importPosition: \"after\"\n        });\n        set(pass, `imports/${importName}`, reference);\n        return reference;\n      } else {\n        let reference = get(pass, `requires/${actualSource}`);\n\n        if (reference) {\n          reference = _core.types.cloneNode(reference);\n        } else {\n          reference = (0, _helperModuleImports.addNamespace)(path, actualSource, {\n            importedInterop: \"uncompiled\"\n          });\n          set(pass, `requires/${actualSource}`, reference);\n        }\n\n        return _core.types.memberExpression(reference, _core.types.identifier(importName));\n      }\n    };\n  }\n}\n\nfunction toMemberExpression(id) {\n  return id.split(\".\").map(name => _core.types.identifier(name)).reduce((object, property) => _core.types.memberExpression(object, property));\n}\n\nfunction makeSource(path, state) {\n  const location = path.node.loc;\n\n  if (!location) {\n    return path.scope.buildUndefinedNode();\n  }\n\n  if (!state.fileNameIdentifier) {\n    const {\n      filename = \"\"\n    } = state;\n    const fileNameIdentifier = path.scope.generateUidIdentifier(\"_jsxFileName\");\n    const scope = path.hub.getScope();\n\n    if (scope) {\n      scope.push({\n        id: fileNameIdentifier,\n        init: _core.types.stringLiteral(filename)\n      });\n    }\n\n    state.fileNameIdentifier = fileNameIdentifier;\n  }\n\n  return makeTrace(_core.types.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);\n}\n\nfunction makeTrace(fileNameIdentifier, lineNumber, column0Based) {\n  const fileLineLiteral = lineNumber != null ? _core.types.numericLiteral(lineNumber) : _core.types.nullLiteral();\n  const fileColumnLiteral = column0Based != null ? _core.types.numericLiteral(column0Based + 1) : _core.types.nullLiteral();\n\n  const fileNameProperty = _core.types.objectProperty(_core.types.identifier(\"fileName\"), fileNameIdentifier);\n\n  const lineNumberProperty = _core.types.objectProperty(_core.types.identifier(\"lineNumber\"), fileLineLiteral);\n\n  const columnNumberProperty = _core.types.objectProperty(_core.types.identifier(\"columnNumber\"), fileColumnLiteral);\n\n  return _core.types.objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);\n}\n\nfunction sourceSelfError(path, name) {\n  const pluginName = `transform-react-jsx-${name.slice(2)}`;\n  return path.buildCodeFrameError(`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`);\n}"]},"metadata":{},"sourceType":"script"}