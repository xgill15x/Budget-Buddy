{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _t = require('@babel/types');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar _t__namespace = /*#__PURE__*/_interopNamespace(_t);\n\nfunction willPathCastToBoolean(path) {\n  const maybeWrapped = path;\n  const {\n    node,\n    parentPath\n  } = maybeWrapped;\n\n  if (parentPath.isLogicalExpression()) {\n    const {\n      operator,\n      right\n    } = parentPath.node;\n\n    if (operator === \"&&\" || operator === \"||\" || operator === \"??\" && node === right) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n\n  if (parentPath.isSequenceExpression()) {\n    const {\n      expressions\n    } = parentPath.node;\n\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      return true;\n    }\n  }\n\n  return parentPath.isConditional({\n    test: node\n  }) || parentPath.isUnaryExpression({\n    operator: \"!\"\n  }) || parentPath.isLoop({\n    test: node\n  });\n}\n\nconst {\n  LOGICAL_OPERATORS,\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  identifier,\n  isMemberExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isUpdateExpression,\n  logicalExpression,\n  memberExpression,\n  nullLiteral,\n  numericLiteral,\n  optionalCallExpression,\n  optionalMemberExpression,\n  sequenceExpression,\n  unaryExpression\n} = _t__namespace;\n\nclass AssignmentMemoiser {\n  constructor() {\n    this._map = void 0;\n    this._map = new WeakMap();\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n\n    const {\n      value\n    } = record;\n    record.count--;\n\n    if (record.count === 0) {\n      return assignmentExpression(\"=\", value, key);\n    }\n\n    return value;\n  }\n\n  set(key, value, count) {\n    return this._map.set(key, {\n      count,\n      value\n    });\n  }\n\n}\n\nfunction toNonOptional(path, base) {\n  const {\n    node\n  } = path;\n\n  if (isOptionalMemberExpression(node)) {\n    return memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      const {\n        object\n      } = callee.node;\n      const context = path.scope.maybeGenerateMemoised(object) || object;\n      callee.get(\"object\").replaceWith(assignmentExpression(\"=\", context, object));\n      return callExpression(memberExpression(base, identifier(\"call\")), [context, ...path.node.arguments]);\n    }\n\n    return callExpression(base, path.node.arguments);\n  }\n\n  return path.node;\n}\n\nfunction isInDetachedTree(path) {\n  while (path) {\n    if (path.isProgram()) break;\n    const {\n      parentPath,\n      container,\n      listKey\n    } = path;\n    const parentNode = parentPath.node;\n\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\nconst handle = {\n  memoise() {},\n\n  handle(member, noDocumentAll) {\n    const {\n      node,\n      parent,\n      parentPath,\n      scope\n    } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      if (isInDetachedTree(member)) return;\n      const endPath = member.find(({\n        node,\n        parent\n      }) => {\n        if (isOptionalMemberExpression(parent)) {\n          return parent.optional || parent.object !== node;\n        }\n\n        if (isOptionalCallExpression(parent)) {\n          return node !== member.node && parent.optional || parent.callee !== node;\n        }\n\n        return true;\n      });\n\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(callExpression(arrowFunctionExpression([], endPath.node), []));\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n      const rootParentPath = endPath.parentPath;\n\n      if (rootParentPath.isUpdateExpression({\n        argument: node\n      }) || rootParentPath.isAssignmentExpression({\n        left: node\n      })) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\"\n      });\n\n      if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get(\"property\").isPrivateName()) {\n        throw member.buildCodeFrameError(`can't delete a private class element`);\n      }\n\n      let startingOptional = member;\n\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n\n        throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);\n      }\n\n      const startingProp = startingOptional.isOptionalMemberExpression() ? \"object\" : \"callee\";\n      const startingNode = startingOptional.node[startingProp];\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node\n      });\n\n      const isOptionalCall = parent => parentIsOptionalCall;\n\n      const parentIsCall = parentPath.isCallExpression({\n        callee: node\n      });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n\n      if (isOptionalCall()) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular = member.node;\n\n      for (let current = member; current !== endPath;) {\n        const parentPath = current.parentPath;\n\n        if (parentPath === endPath && isOptionalCall() && parent.optional) {\n          regular = parentPath.node;\n          break;\n        }\n\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context;\n      const endParentPath = endPath.parentPath;\n\n      if (isMemberExpression(regular) && endParentPath.isOptionalCallExpression({\n        callee: endPath.node,\n        optional: true\n      })) {\n        const {\n          object\n        } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n\n        if (context) {\n          regular.object = assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      let replacementPath = endPath;\n\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      const baseMemoised = baseNeedsMemoised ? assignmentExpression(\"=\", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        let nonNullishCheck;\n\n        if (noDocumentAll) {\n          nonNullishCheck = binaryExpression(\"!=\", baseMemoised, nullLiteral());\n        } else {\n          nonNullishCheck = logicalExpression(\"&&\", binaryExpression(\"!==\", baseMemoised, nullLiteral()), binaryExpression(\"!==\", cloneNode(baseRef), scope.buildUndefinedNode()));\n        }\n\n        replacementPath.replaceWith(logicalExpression(\"&&\", nonNullishCheck, regular));\n      } else {\n        let nullishCheck;\n\n        if (noDocumentAll) {\n          nullishCheck = binaryExpression(\"==\", baseMemoised, nullLiteral());\n        } else {\n          nullishCheck = logicalExpression(\"||\", binaryExpression(\"===\", baseMemoised, nullLiteral()), binaryExpression(\"===\", cloneNode(baseRef), scope.buildUndefinedNode()));\n        }\n\n        replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral(true) : scope.buildUndefinedNode(), regular));\n      }\n\n      if (context) {\n        const endParent = endParentPath.node;\n        endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee, identifier(\"call\"), false, true), [cloneNode(context), ...endParent.arguments], false));\n      }\n\n      return;\n    }\n\n    if (isUpdateExpression(parent, {\n      argument: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        prefix\n      } = parent;\n      this.memoise(member, 2);\n      const value = binaryExpression(operator[0], unaryExpression(\"+\", this.get(member)), numericLiteral(1));\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const {\n          scope\n        } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({\n          id: ref\n        });\n        value.left = assignmentExpression(\"=\", cloneNode(ref), value.left);\n        parentPath.replaceWith(sequenceExpression([this.set(member, value), cloneNode(ref)]));\n      }\n\n      return;\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        right: value\n      } = parentPath.node;\n\n      if (operator === \"=\") {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const operatorTrunc = operator.slice(0, -1);\n\n        if (LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          this.memoise(member, 1);\n          parentPath.replaceWith(logicalExpression(operatorTrunc, this.get(member), this.set(member, value)));\n        } else {\n          this.memoise(member, 2);\n          parentPath.replaceWith(this.set(member, binaryExpression(operatorTrunc, this.get(member), value)));\n        }\n      }\n\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.call(member, parentPath.node.arguments));\n      return;\n    }\n\n    if (parentPath.isOptionalCallExpression({\n      callee: node\n    })) {\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(callExpression(arrowFunctionExpression([], parentPath.node), []));\n        return;\n      }\n\n      parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments));\n      return;\n    }\n\n    if (parentPath.isForXStatement({\n      left: node\n    }) || parentPath.isObjectProperty({\n      value: node\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isObjectProperty({\n      value: parent\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      member.replaceWith(this.boundGet(member));\n    } else {\n      member.replaceWith(this.get(member));\n    }\n  }\n\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}\n\nexports.default = memberExpressionToFunctions;","map":{"version":3,"sources":["../src/util.ts","../src/index.ts"],"names":["maybeWrapped","parentPath","right","operator","node","willPathCastToBoolean","expressions","test","LOGICAL_OPERATORS","arrowFunctionExpression","assignmentExpression","binaryExpression","booleanLiteral","callExpression","cloneNode","conditionalExpression","identifier","isMemberExpression","isOptionalCallExpression","isOptionalMemberExpression","isUpdateExpression","logicalExpression","memberExpression","nullLiteral","numericLiteral","optionalCallExpression","optionalMemberExpression","sequenceExpression","unaryExpression","_map","constructor","has","get","record","value","set","path","callee","object","context","listKey","parentNode","container","handle","memoise","scope","member","isInDetachedTree","endPath","parent","willEndPathCastToBoolean","rootParentPath","argument","left","isDeleteOperation","startingOptional","type","startingProp","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","isOptionalCall","parentIsCall","toNonOptional","regular","current","endParentPath","optional","replacementPath","baseMemoised","nonNullishCheck","nullishCheck","endParent","prefix","ref","id","operatorTrunc","memoiser"],"mappings":"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","sourcesContent":["import type { NodePath } from \"@babel/traverse\";\n\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n *\n * @example\n * // returns true\n * const nodePathAQDotB = NodePath(\"if (a?.#b) {}\").get(\"test\"); // a?.#b\n * willPathCastToBoolean(nodePathAQDotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a?.#b\"))\n * @todo Respect transparent expression wrappers\n * @see {@link packages/babel-plugin-proposal-optional-chaining/src/util.js}\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = path;\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n","import type { NodePath, Visitor } from \"@babel/traverse\";\nimport {\n  LOGICAL_OPERATORS,\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  identifier,\n  isMemberExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isUpdateExpression,\n  logicalExpression,\n  memberExpression,\n  nullLiteral,\n  numericLiteral,\n  optionalCallExpression,\n  optionalMemberExpression,\n  sequenceExpression,\n  unaryExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { willPathCastToBoolean } from \"./util\";\n\nclass AssignmentMemoiser {\n  private _map: WeakMap<t.Expression, { count: number; value: t.LVal }>;\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key: t.Expression) {\n    return this._map.has(key);\n  }\n\n  get(key: t.Expression) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n    const { value } = record;\n\n    record.count--;\n    if (record.count === 0) {\n      // The `count` access is the outermost function call (hopefully), so it\n      // does the assignment.\n      return assignmentExpression(\"=\", value, key);\n    }\n    return value;\n  }\n\n  set(key: t.Expression, value: t.LVal, count: number) {\n    return this._map.set(key, { count, value });\n  }\n}\n\nfunction toNonOptional(\n  path: NodePath<t.Expression>,\n  base: t.Expression,\n): t.Expression {\n  const { node } = path;\n  if (isOptionalMemberExpression(node)) {\n    return memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      const { object } = callee.node;\n      const context = path.scope.maybeGenerateMemoised(object) || object;\n      callee\n        .get(\"object\")\n        .replaceWith(assignmentExpression(\"=\", context as t.LVal, object));\n\n      return callExpression(memberExpression(base, identifier(\"call\")), [\n        context,\n        ...path.node.arguments,\n      ]);\n    }\n\n    return callExpression(base, path.node.arguments);\n  }\n\n  return path.node;\n}\n\n// Determines if the current path is in a detached tree. This can happen when\n// we are iterating on a path, and replace an ancestor with a new node. Babel\n// doesn't always stop traversing the old node tree, and that can cause\n// inconsistencies.\nfunction isInDetachedTree(path: NodePath) {\n  while (path) {\n    if (path.isProgram()) break;\n\n    const { parentPath, container, listKey } = path;\n    const parentNode = parentPath.node;\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\ntype Member = NodePath<t.OptionalMemberExpression | t.MemberExpression>;\n\nconst handle = {\n  memoise() {\n    // noop.\n  },\n\n  handle(this: HandlerState, member: Member, noDocumentAll: boolean) {\n    const { node, parent, parentPath, scope } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      // Transforming optional chaining requires we replace ancestors.\n      if (isInDetachedTree(member)) return;\n\n      // We're looking for the end of _this_ optional chain, which is actually\n      // the \"rightmost\" property access of the chain. This is because\n      // everything up to that property access is \"optional\".\n      //\n      // Let's take the case of `FOO?.BAR.baz?.qux`, with `FOO?.BAR` being our\n      // member. The \"end\" to most users would be `qux` property access.\n      // Everything up to it could be skipped if it `FOO` were nullish. But\n      // actually, we can consider the `baz` access to be the end. So we're\n      // looking for the nearest optional chain that is `optional: true`.\n      const endPath = member.find(({ node, parent }) => {\n        if (isOptionalMemberExpression(parent)) {\n          // We need to check `parent.object` since we could be inside the\n          // computed expression of a `bad?.[FOO?.BAR]`. In this case, the\n          // endPath is the `FOO?.BAR` member itself.\n          return parent.optional || parent.object !== node;\n        }\n        if (isOptionalCallExpression(parent)) {\n          // Checking `parent.callee` since we could be in the arguments, eg\n          // `bad?.(FOO?.BAR)`.\n          // Also skip `FOO?.BAR` in `FOO?.BAR?.()` since we need to transform the optional call to ensure proper this\n          return (\n            // In FOO?.#BAR?.(), endPath points the optional call expression so we skip FOO?.#BAR\n            (node !== member.node && parent.optional) || parent.callee !== node\n          );\n        }\n        return true;\n      }) as NodePath<t.OptionalMemberExpression>;\n\n      // Replace `function (a, x = a.b?.#c) {}` to `function (a, x = (() => a.b?.#c)() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], endPath.node), []),\n        );\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n\n      const rootParentPath = endPath.parentPath;\n      if (\n        rootParentPath.isUpdateExpression({ argument: node }) ||\n        rootParentPath.isAssignmentExpression({ left: node })\n      ) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\",\n      });\n      if (\n        isDeleteOperation &&\n        endPath.isOptionalMemberExpression() &&\n        endPath.get(\"property\").isPrivateName()\n      ) {\n        // @babel/parser will throw error on `delete obj?.#x`.\n        // This error serves as fallback when `delete obj?.#x` is constructed from babel types\n        throw member.buildCodeFrameError(\n          `can't delete a private class element`,\n        );\n      }\n\n      // Now, we're looking for the start of this optional chain, which is\n      // optional to the left of this member.\n      //\n      // Let's take the case of `foo?.bar?.baz.QUX?.BAM`, with `QUX?.BAM` being\n      // our member. The \"start\" to most users would be `foo` object access.\n      // But actually, we can consider the `bar` access to be the start. So\n      // we're looking for the nearest optional chain that is `optional: true`,\n      // which is guaranteed to be somewhere in the object/callee tree.\n      let startingOptional: NodePath<t.Expression> = member;\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n        // prevent infinite loop: unreachable if the AST is well-formed\n        throw new Error(\n          `Internal error: unexpected ${startingOptional.node.type}`,\n        );\n      }\n\n      const startingProp = startingOptional.isOptionalMemberExpression()\n        ? \"object\"\n        : \"callee\";\n      const startingNode = startingOptional.node[startingProp];\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised ?? startingNode;\n\n      // Compute parentIsOptionalCall before `startingOptional` is replaced\n      // as `node` may refer to `startingOptional.node` before replaced.\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node,\n      });\n      // here we use a function to wrap `parentIsOptionalCall` to get type\n      // for parent, do not use it anywhere else\n      // See https://github.com/microsoft/TypeScript/issues/10421\n      const isOptionalCall = (\n        parent: t.Node,\n      ): parent is t.OptionalCallExpression => parentIsOptionalCall;\n      // if parentIsCall is true, it implies that node.extra.parenthesized is always true\n      const parentIsCall = parentPath.isCallExpression({ callee: node });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n      if (isOptionalCall(parent)) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        // `(a?.#b)()` to `(a == null ? void 0 : a.#b.bind(a))()`\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular: t.Expression = member.node;\n      for (let current: NodePath = member; current !== endPath; ) {\n        const parentPath = current.parentPath as NodePath<t.Expression>;\n        // skip transforming `Foo.#BAR?.call(FOO)`\n        if (\n          parentPath === endPath &&\n          isOptionalCall(parent) &&\n          parent.optional\n        ) {\n          regular = parentPath.node;\n          break;\n        }\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context: t.Identifier;\n      const endParentPath = endPath.parentPath as NodePath<t.Expression>;\n      if (\n        isMemberExpression(regular) &&\n        endParentPath.isOptionalCallExpression({\n          callee: endPath.node,\n          optional: true,\n        })\n      ) {\n        const { object } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n        if (context) {\n          regular.object = assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      let replacementPath: NodePath = endPath;\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      const baseMemoised = baseNeedsMemoised\n        ? assignmentExpression(\"=\", cloneNode(baseRef), cloneNode(startingNode))\n        : cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        let nonNullishCheck;\n        if (noDocumentAll) {\n          nonNullishCheck = binaryExpression(\"!=\", baseMemoised, nullLiteral());\n        } else {\n          nonNullishCheck = logicalExpression(\n            \"&&\",\n            binaryExpression(\"!==\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"!==\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n        replacementPath.replaceWith(\n          logicalExpression(\"&&\", nonNullishCheck, regular),\n        );\n      } else {\n        let nullishCheck;\n        if (noDocumentAll) {\n          nullishCheck = binaryExpression(\"==\", baseMemoised, nullLiteral());\n        } else {\n          nullishCheck = logicalExpression(\n            \"||\",\n            binaryExpression(\"===\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"===\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n\n        replacementPath.replaceWith(\n          conditionalExpression(\n            nullishCheck,\n            isDeleteOperation\n              ? booleanLiteral(true)\n              : scope.buildUndefinedNode(),\n            regular,\n          ),\n        );\n      }\n\n      // context and isDeleteOperation can not be both truthy\n      if (context) {\n        const endParent = endParentPath.node as t.OptionalCallExpression;\n        endParentPath.replaceWith(\n          optionalCallExpression(\n            optionalMemberExpression(\n              endParent.callee,\n              identifier(\"call\"),\n              false,\n              true,\n            ),\n            [cloneNode(context), ...endParent.arguments],\n            false,\n          ),\n        );\n      }\n\n      return;\n    }\n\n    // MEMBER++   ->   _set(MEMBER, (_ref = (+_get(MEMBER))) + 1), _ref\n    // ++MEMBER   ->   _set(MEMBER, (+_get(MEMBER)) + 1)\n    if (isUpdateExpression(parent, { argument: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, prefix } = parent;\n\n      // Give the state handler a chance to memoise the member, since we'll\n      // reference it twice. The second access (the set) should do the memo\n      // assignment.\n      this.memoise(member, 2);\n\n      const value = binaryExpression(\n        operator[0] as \"+\" | \"-\",\n        unaryExpression(\"+\", this.get(member)),\n        numericLiteral(1),\n      );\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const { scope } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({ id: ref });\n\n        value.left = assignmentExpression(\n          \"=\",\n          cloneNode(ref),\n          // @ts-expect-error todo(flow->ts) value.left is possibly PrivateName, which is not usable here\n          value.left,\n        );\n\n        parentPath.replaceWith(\n          sequenceExpression([this.set(member, value), cloneNode(ref)]),\n        );\n      }\n      return;\n    }\n\n    // MEMBER = VALUE   ->   _set(MEMBER, VALUE)\n    // MEMBER += VALUE   ->   _set(MEMBER, _get(MEMBER) + VALUE)\n    // MEMBER ??= VALUE   ->   _get(MEMBER) ?? _set(MEMBER, VALUE)\n    if (parentPath.isAssignmentExpression({ left: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, right: value } = parentPath.node;\n\n      if (operator === \"=\") {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const operatorTrunc = operator.slice(0, -1);\n        if (LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          // Give the state handler a chance to memoise the member, since we'll\n          // reference it twice. The first access (the get) should do the memo\n          // assignment.\n          this.memoise(member, 1);\n          parentPath.replaceWith(\n            logicalExpression(\n              operatorTrunc as t.LogicalExpression[\"operator\"],\n              this.get(member),\n              this.set(member, value),\n            ),\n          );\n        } else {\n          // Here, the second access (the set) is evaluated first.\n          this.memoise(member, 2);\n          parentPath.replaceWith(\n            this.set(\n              member,\n              binaryExpression(\n                operatorTrunc as t.BinaryExpression[\"operator\"],\n                this.get(member),\n                value,\n              ),\n            ),\n          );\n        }\n      }\n      return;\n    }\n\n    // MEMBER(ARGS) -> _call(MEMBER, ARGS)\n    if (parentPath.isCallExpression({ callee: node })) {\n      parentPath.replaceWith(this.call(member, parentPath.node.arguments));\n      return;\n    }\n\n    // MEMBER?.(ARGS) -> _optionalCall(MEMBER, ARGS)\n    if (parentPath.isOptionalCallExpression({ callee: node })) {\n      // Replace `function (a, x = a.b.#c?.()) {}` to `function (a, x = (() => a.b.#c?.())() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], parentPath.node), []),\n        );\n        return;\n      }\n      parentPath.replaceWith(\n        this.optionalCall(member, parentPath.node.arguments),\n      );\n      return;\n    }\n\n    // for (MEMBER of ARR)\n    // for (MEMBER in ARR)\n    // { KEY: MEMBER } = OBJ -> { KEY: _destructureSet(MEMBER) } = OBJ\n    // { KEY: MEMBER = _VALUE } = OBJ -> { KEY: _destructureSet(MEMBER) = _VALUE } = OBJ\n    // {...MEMBER} -> {..._destructureSet(MEMBER)}\n    //\n    // [MEMBER] = ARR -> [_destructureSet(MEMBER)] = ARR\n    // [MEMBER = _VALUE] = ARR -> [_destructureSet(MEMBER) = _VALUE] = ARR\n    // [...MEMBER] -> [..._destructureSet(MEMBER)]\n    if (\n      // for (MEMBER of ARR)\n      // for (MEMBER in ARR)\n      parentPath.isForXStatement({ left: node }) ||\n      // { KEY: MEMBER } = OBJ\n      (parentPath.isObjectProperty({ value: node }) &&\n        parentPath.parentPath.isObjectPattern()) ||\n      // { KEY: MEMBER = _VALUE } = OBJ\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isObjectProperty({ value: parent }) &&\n        parentPath.parentPath.parentPath.isObjectPattern()) ||\n      // [MEMBER] = ARR\n      parentPath.isArrayPattern() ||\n      // [MEMBER = _VALUE] = ARR\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isArrayPattern()) ||\n      // {...MEMBER}\n      // [...MEMBER]\n      parentPath.isRestElement()\n    ) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      // MEMBER   ->   _get(MEMBER).bind(this)\n      member.replaceWith(this.boundGet(member));\n    } else {\n      // MEMBER   ->   _get(MEMBER)\n      member.replaceWith(this.get(member));\n    }\n  },\n};\n\nexport interface Handler<State> {\n  memoise?(\n    this: HandlerState<State> & State,\n    member: Member,\n    count: number,\n  ): void;\n  destructureSet(\n    this: HandlerState<State> & State,\n    member: Member,\n  ): t.Expression;\n  boundGet(this: HandlerState<State> & State, member: Member): t.Expression;\n  simpleSet?(this: HandlerState<State> & State, member: Member): t.Expression;\n  get(this: HandlerState<State> & State, member: Member): t.Expression;\n  set(\n    this: HandlerState<State> & State,\n    member: Member,\n    value: t.Expression,\n  ): t.Expression;\n  call(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.CallExpression[\"arguments\"],\n  ): t.Expression;\n  optionalCall(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.OptionalCallExpression[\"arguments\"],\n  ): t.Expression;\n}\n\nexport interface HandlerState<State = {}> extends Handler<State> {\n  handle(\n    this: HandlerState<State> & State,\n    member: Member,\n    noDocumentAll: boolean,\n  ): void;\n  memoiser: AssignmentMemoiser;\n}\n\n// We do not provide a default traversal visitor\n// Instead, caller passes one, and must call `state.handle` on the members\n// it wishes to be transformed.\n// Additionally, the caller must pass in a state object with at least\n// get, set, and call methods.\n// Optionally, a memoise method may be defined on the state, which will be\n// called when the member is a self-referential update.\nexport default function memberExpressionToFunctions<CustomState = {}>(\n  path: NodePath,\n  visitor: Visitor<HandlerState<CustomState>>,\n  state: Handler<CustomState> & CustomState,\n) {\n  path.traverse(visitor, {\n    ...handle,\n    ...state,\n    memoiser: new AssignmentMemoiser(),\n  });\n}\n"]},"metadata":{},"sourceType":"script"}