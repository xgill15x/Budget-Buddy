{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.skipAllButComputedKey = skipAllButComputedKey;\nexports.default = exports.environmentVisitor = void 0;\n\nvar _traverse = require(\"@babel/traverse\");\n\nvar _helperMemberExpressionToFunctions = require(\"@babel/helper-member-expression-to-functions\");\n\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS,\n  assignmentExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  staticBlock,\n  stringLiteral,\n  thisExpression\n} = _t;\n\nfunction getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {\n  objectRef = cloneNode(objectRef);\n  const targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier(\"prototype\"));\n  return callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nfunction skipAllButComputedKey(path) {\n  if (!path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}\n\nconst environmentVisitor = {\n  [`${staticBlock ? \"StaticBlock|\" : \"\"}ClassPrivateProperty|TypeAnnotation`](path) {\n    path.skip();\n  },\n\n  Function(path) {\n    if (path.isMethod()) return;\n    if (path.isArrowFunctionExpression()) return;\n    path.skip();\n  },\n\n  \"Method|ClassProperty\"(path) {\n    skipAllButComputedKey(path);\n  }\n\n};\nexports.environmentVisitor = environmentVisitor;\n\nconst visitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Super(path, state) {\n    const {\n      node,\n      parentPath\n    } = path;\n    if (!parentPath.isMemberExpression({\n      object: node\n    })) return;\n    state.handle(parentPath);\n  }\n\n}]);\n\nconst unshadowSuperBindingVisitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Scopable(path, {\n    refName\n  }) {\n    const binding = path.scope.getOwnBinding(refName);\n\n    if (binding && binding.identifier.name === refName) {\n      path.scope.rename(refName);\n    }\n  }\n\n}]);\n\nconst specHandlers = {\n  memoise(superMember, count) {\n    const {\n      scope,\n      node\n    } = superMember;\n    const {\n      computed,\n      property\n    } = node;\n\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(superMember) {\n    const {\n      computed,\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return cloneNode(property);\n    }\n\n    return stringLiteral(property.name);\n  },\n\n  get(superMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n\n  _get(superMember, thisRefs) {\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return callExpression(this.file.addHelper(\"get\"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs.this]);\n  },\n\n  _getThisRefs() {\n    if (!this.isDerivedConstructor) {\n      return {\n        this: thisExpression()\n      };\n    }\n\n    const thisRef = this.scope.generateDeclaredUidIdentifier(\"thisSuper\");\n    return {\n      memo: assignmentExpression(\"=\", thisRef, thisExpression()),\n      this: cloneNode(thisRef)\n    };\n  },\n\n  set(superMember, value) {\n    const thisRefs = this._getThisRefs();\n\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return callExpression(this.file.addHelper(\"set\"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs.this, booleanLiteral(superMember.isInStrictMode())]);\n  },\n\n  destructureSet(superMember) {\n    throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);\n  },\n\n  call(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, true);\n  }\n\n};\nconst looseHandlers = Object.assign({}, specHandlers, {\n  prop(superMember) {\n    const {\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    return cloneNode(property);\n  },\n\n  get(superMember) {\n    const {\n      isStatic,\n      getSuperRef\n    } = this;\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    let object;\n\n    if (isStatic) {\n      var _getSuperRef;\n\n      object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier(\"Function\"), identifier(\"prototype\"));\n    } else {\n      var _getSuperRef2;\n\n      object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier(\"Object\"), identifier(\"prototype\"));\n    }\n\n    return memberExpression(object, prop, computed);\n  },\n\n  set(superMember, value) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return assignmentExpression(\"=\", memberExpression(thisExpression(), prop, computed), value);\n  },\n\n  destructureSet(superMember) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return memberExpression(thisExpression(), prop, computed);\n  },\n\n  call(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, true);\n  }\n\n});\n\nclass ReplaceSupers {\n  constructor(opts) {\n    var _opts$constantSuper;\n\n    const path = opts.methodPath;\n    this.methodPath = path;\n    this.isDerivedConstructor = path.isClassMethod({\n      kind: \"constructor\"\n    }) && !!opts.superRef;\n    this.isStatic = path.isObjectMethod() || path.node.static || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n    this.file = opts.file;\n    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;\n    this.opts = opts;\n  }\n\n  getObjectRef() {\n    return cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n\n  getSuperRef() {\n    if (this.opts.superRef) return cloneNode(this.opts.superRef);\n    if (this.opts.getSuperRef) return cloneNode(this.opts.getSuperRef());\n  }\n\n  replace() {\n    if (this.opts.refToPreserve) {\n      this.methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name\n      });\n    }\n\n    const handler = this.constantSuper ? looseHandlers : specHandlers;\n    (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      getSuperRef: this.getSuperRef.bind(this),\n      boundGet: handler.get\n    }, handler));\n  }\n\n}\n\nexports.default = ReplaceSupers;","map":{"version":3,"sources":["C:/Users/jason/OneDrive/desktop/BudgetTracker/react/node_modules/@babel/helper-replace-supers/lib/index.js"],"names":["Object","defineProperty","exports","value","skipAllButComputedKey","default","environmentVisitor","_traverse","require","_helperMemberExpressionToFunctions","_helperOptimiseCallExpression","_t","VISITOR_KEYS","assignmentExpression","booleanLiteral","callExpression","cloneNode","identifier","memberExpression","sequenceExpression","staticBlock","stringLiteral","thisExpression","getPrototypeOfExpression","objectRef","isStatic","file","isPrivateMethod","targetRef","addHelper","path","node","computed","skip","keys","type","key","skipKey","Function","isMethod","isArrowFunctionExpression","visitor","visitors","merge","Super","state","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","property","memo","maybeGenerateMemoised","memoiser","set","prop","has","get","_get","_getThisRefs","thisRefs","proto","getObjectRef","this","isDerivedConstructor","thisRef","generateDeclaredUidIdentifier","isInStrictMode","destructureSet","buildCodeFrameError","call","args","optionalCall","looseHandlers","assign","getSuperRef","_getSuperRef","_getSuperRef2","ReplaceSupers","constructor","opts","_opts$constantSuper","methodPath","isClassMethod","kind","superRef","isObjectMethod","static","isStaticBlock","isPrivate","constantSuper","isLoose","replace","refToPreserve","traverse","handler","bind","boundGet"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,qBAAR,GAAgCA,qBAAhC;AACAF,OAAO,CAACG,OAAR,GAAkBH,OAAO,CAACI,kBAAR,GAA6B,KAAK,CAApD;;AAEA,IAAIC,SAAS,GAAGC,OAAO,CAAC,iBAAD,CAAvB;;AAEA,IAAIC,kCAAkC,GAAGD,OAAO,CAAC,8CAAD,CAAhD;;AAEA,IAAIE,6BAA6B,GAAGF,OAAO,CAAC,wCAAD,CAA3C;;AAEA,IAAIG,EAAE,GAAGH,OAAO,CAAC,cAAD,CAAhB;;AAEA,MAAM;AACJI,EAAAA,YADI;AAEJC,EAAAA,oBAFI;AAGJC,EAAAA,cAHI;AAIJC,EAAAA,cAJI;AAKJC,EAAAA,SALI;AAMJC,EAAAA,UANI;AAOJC,EAAAA,gBAPI;AAQJC,EAAAA,kBARI;AASJC,EAAAA,WATI;AAUJC,EAAAA,aAVI;AAWJC,EAAAA;AAXI,IAYFX,EAZJ;;AAcA,SAASY,wBAAT,CAAkCC,SAAlC,EAA6CC,QAA7C,EAAuDC,IAAvD,EAA6DC,eAA7D,EAA8E;AAC5EH,EAAAA,SAAS,GAAGR,SAAS,CAACQ,SAAD,CAArB;AACA,QAAMI,SAAS,GAAGH,QAAQ,IAAIE,eAAZ,GAA8BH,SAA9B,GAA0CN,gBAAgB,CAACM,SAAD,EAAYP,UAAU,CAAC,WAAD,CAAtB,CAA5E;AACA,SAAOF,cAAc,CAACW,IAAI,CAACG,SAAL,CAAe,gBAAf,CAAD,EAAmC,CAACD,SAAD,CAAnC,CAArB;AACD;;AAED,SAASxB,qBAAT,CAA+B0B,IAA/B,EAAqC;AACnC,MAAI,CAACA,IAAI,CAACC,IAAL,CAAUC,QAAf,EAAyB;AACvBF,IAAAA,IAAI,CAACG,IAAL;AACA;AACD;;AAED,QAAMC,IAAI,GAAGtB,YAAY,CAACkB,IAAI,CAACK,IAAN,CAAzB;;AAEA,OAAK,MAAMC,GAAX,IAAkBF,IAAlB,EAAwB;AACtB,QAAIE,GAAG,KAAK,KAAZ,EAAmBN,IAAI,CAACO,OAAL,CAAaD,GAAb;AACpB;AACF;;AAED,MAAM9B,kBAAkB,GAAG;AACzB,GAAE,GAAEc,WAAW,GAAG,cAAH,GAAoB,EAAG,qCAAtC,EAA4EU,IAA5E,EAAkF;AAChFA,IAAAA,IAAI,CAACG,IAAL;AACD,GAHwB;;AAKzBK,EAAAA,QAAQ,CAACR,IAAD,EAAO;AACb,QAAIA,IAAI,CAACS,QAAL,EAAJ,EAAqB;AACrB,QAAIT,IAAI,CAACU,yBAAL,EAAJ,EAAsC;AACtCV,IAAAA,IAAI,CAACG,IAAL;AACD,GATwB;;AAWzB,yBAAuBH,IAAvB,EAA6B;AAC3B1B,IAAAA,qBAAqB,CAAC0B,IAAD,CAArB;AACD;;AAbwB,CAA3B;AAgBA5B,OAAO,CAACI,kBAAR,GAA6BA,kBAA7B;;AAEA,MAAMmC,OAAO,GAAGlC,SAAS,CAACF,OAAV,CAAkBqC,QAAlB,CAA2BC,KAA3B,CAAiC,CAACrC,kBAAD,EAAqB;AACpEsC,EAAAA,KAAK,CAACd,IAAD,EAAOe,KAAP,EAAc;AACjB,UAAM;AACJd,MAAAA,IADI;AAEJe,MAAAA;AAFI,QAGFhB,IAHJ;AAIA,QAAI,CAACgB,UAAU,CAACC,kBAAX,CAA8B;AACjCC,MAAAA,MAAM,EAAEjB;AADyB,KAA9B,CAAL,EAEI;AACJc,IAAAA,KAAK,CAACI,MAAN,CAAaH,UAAb;AACD;;AAVmE,CAArB,CAAjC,CAAhB;;AAcA,MAAMI,2BAA2B,GAAG3C,SAAS,CAACF,OAAV,CAAkBqC,QAAlB,CAA2BC,KAA3B,CAAiC,CAACrC,kBAAD,EAAqB;AACxF6C,EAAAA,QAAQ,CAACrB,IAAD,EAAO;AACbsB,IAAAA;AADa,GAAP,EAEL;AACD,UAAMC,OAAO,GAAGvB,IAAI,CAACwB,KAAL,CAAWC,aAAX,CAAyBH,OAAzB,CAAhB;;AAEA,QAAIC,OAAO,IAAIA,OAAO,CAACpC,UAAR,CAAmBuC,IAAnB,KAA4BJ,OAA3C,EAAoD;AAClDtB,MAAAA,IAAI,CAACwB,KAAL,CAAWG,MAAX,CAAkBL,OAAlB;AACD;AACF;;AATuF,CAArB,CAAjC,CAApC;;AAaA,MAAMM,YAAY,GAAG;AACnBC,EAAAA,OAAO,CAACC,WAAD,EAAcC,KAAd,EAAqB;AAC1B,UAAM;AACJP,MAAAA,KADI;AAEJvB,MAAAA;AAFI,QAGF6B,WAHJ;AAIA,UAAM;AACJ5B,MAAAA,QADI;AAEJ8B,MAAAA;AAFI,QAGF/B,IAHJ;;AAKA,QAAI,CAACC,QAAL,EAAe;AACb;AACD;;AAED,UAAM+B,IAAI,GAAGT,KAAK,CAACU,qBAAN,CAA4BF,QAA5B,CAAb;;AAEA,QAAI,CAACC,IAAL,EAAW;AACT;AACD;;AAED,SAAKE,QAAL,CAAcC,GAAd,CAAkBJ,QAAlB,EAA4BC,IAA5B,EAAkCF,KAAlC;AACD,GAtBkB;;AAwBnBM,EAAAA,IAAI,CAACP,WAAD,EAAc;AAChB,UAAM;AACJ5B,MAAAA,QADI;AAEJ8B,MAAAA;AAFI,QAGFF,WAAW,CAAC7B,IAHhB;;AAKA,QAAI,KAAKkC,QAAL,CAAcG,GAAd,CAAkBN,QAAlB,CAAJ,EAAiC;AAC/B,aAAO9C,SAAS,CAAC,KAAKiD,QAAL,CAAcI,GAAd,CAAkBP,QAAlB,CAAD,CAAhB;AACD;;AAED,QAAI9B,QAAJ,EAAc;AACZ,aAAOhB,SAAS,CAAC8C,QAAD,CAAhB;AACD;;AAED,WAAOzC,aAAa,CAACyC,QAAQ,CAACN,IAAV,CAApB;AACD,GAvCkB;;AAyCnBa,EAAAA,GAAG,CAACT,WAAD,EAAc;AACf,WAAO,KAAKU,IAAL,CAAUV,WAAV,EAAuB,KAAKW,YAAL,EAAvB,CAAP;AACD,GA3CkB;;AA6CnBD,EAAAA,IAAI,CAACV,WAAD,EAAcY,QAAd,EAAwB;AAC1B,UAAMC,KAAK,GAAGlD,wBAAwB,CAAC,KAAKmD,YAAL,EAAD,EAAsB,KAAKjD,QAA3B,EAAqC,KAAKC,IAA1C,EAAgD,KAAKC,eAArD,CAAtC;AACA,WAAOZ,cAAc,CAAC,KAAKW,IAAL,CAAUG,SAAV,CAAoB,KAApB,CAAD,EAA6B,CAAC2C,QAAQ,CAACT,IAAT,GAAgB5C,kBAAkB,CAAC,CAACqD,QAAQ,CAACT,IAAV,EAAgBU,KAAhB,CAAD,CAAlC,GAA6DA,KAA9D,EAAqE,KAAKN,IAAL,CAAUP,WAAV,CAArE,EAA6FY,QAAQ,CAACG,IAAtG,CAA7B,CAArB;AACD,GAhDkB;;AAkDnBJ,EAAAA,YAAY,GAAG;AACb,QAAI,CAAC,KAAKK,oBAAV,EAAgC;AAC9B,aAAO;AACLD,QAAAA,IAAI,EAAErD,cAAc;AADf,OAAP;AAGD;;AAED,UAAMuD,OAAO,GAAG,KAAKvB,KAAL,CAAWwB,6BAAX,CAAyC,WAAzC,CAAhB;AACA,WAAO;AACLf,MAAAA,IAAI,EAAElD,oBAAoB,CAAC,GAAD,EAAMgE,OAAN,EAAevD,cAAc,EAA7B,CADrB;AAELqD,MAAAA,IAAI,EAAE3D,SAAS,CAAC6D,OAAD;AAFV,KAAP;AAID,GA9DkB;;AAgEnBX,EAAAA,GAAG,CAACN,WAAD,EAAczD,KAAd,EAAqB;AACtB,UAAMqE,QAAQ,GAAG,KAAKD,YAAL,EAAjB;;AAEA,UAAME,KAAK,GAAGlD,wBAAwB,CAAC,KAAKmD,YAAL,EAAD,EAAsB,KAAKjD,QAA3B,EAAqC,KAAKC,IAA1C,EAAgD,KAAKC,eAArD,CAAtC;AACA,WAAOZ,cAAc,CAAC,KAAKW,IAAL,CAAUG,SAAV,CAAoB,KAApB,CAAD,EAA6B,CAAC2C,QAAQ,CAACT,IAAT,GAAgB5C,kBAAkB,CAAC,CAACqD,QAAQ,CAACT,IAAV,EAAgBU,KAAhB,CAAD,CAAlC,GAA6DA,KAA9D,EAAqE,KAAKN,IAAL,CAAUP,WAAV,CAArE,EAA6FzD,KAA7F,EAAoGqE,QAAQ,CAACG,IAA7G,EAAmH7D,cAAc,CAAC8C,WAAW,CAACmB,cAAZ,EAAD,CAAjI,CAA7B,CAArB;AACD,GArEkB;;AAuEnBC,EAAAA,cAAc,CAACpB,WAAD,EAAc;AAC1B,UAAMA,WAAW,CAACqB,mBAAZ,CAAiC,sDAAjC,CAAN;AACD,GAzEkB;;AA2EnBC,EAAAA,IAAI,CAACtB,WAAD,EAAcuB,IAAd,EAAoB;AACtB,UAAMX,QAAQ,GAAG,KAAKD,YAAL,EAAjB;;AAEA,WAAO,CAAC,GAAG7D,6BAA6B,CAACL,OAAlC,EAA2C,KAAKiE,IAAL,CAAUV,WAAV,EAAuBY,QAAvB,CAA3C,EAA6ExD,SAAS,CAACwD,QAAQ,CAACG,IAAV,CAAtF,EAAuGQ,IAAvG,EAA6G,KAA7G,CAAP;AACD,GA/EkB;;AAiFnBC,EAAAA,YAAY,CAACxB,WAAD,EAAcuB,IAAd,EAAoB;AAC9B,UAAMX,QAAQ,GAAG,KAAKD,YAAL,EAAjB;;AAEA,WAAO,CAAC,GAAG7D,6BAA6B,CAACL,OAAlC,EAA2C,KAAKiE,IAAL,CAAUV,WAAV,EAAuBY,QAAvB,CAA3C,EAA6ExD,SAAS,CAACwD,QAAQ,CAACG,IAAV,CAAtF,EAAuGQ,IAAvG,EAA6G,IAA7G,CAAP;AACD;;AArFkB,CAArB;AAwFA,MAAME,aAAa,GAAGrF,MAAM,CAACsF,MAAP,CAAc,EAAd,EAAkB5B,YAAlB,EAAgC;AACpDS,EAAAA,IAAI,CAACP,WAAD,EAAc;AAChB,UAAM;AACJE,MAAAA;AADI,QAEFF,WAAW,CAAC7B,IAFhB;;AAIA,QAAI,KAAKkC,QAAL,CAAcG,GAAd,CAAkBN,QAAlB,CAAJ,EAAiC;AAC/B,aAAO9C,SAAS,CAAC,KAAKiD,QAAL,CAAcI,GAAd,CAAkBP,QAAlB,CAAD,CAAhB;AACD;;AAED,WAAO9C,SAAS,CAAC8C,QAAD,CAAhB;AACD,GAXmD;;AAapDO,EAAAA,GAAG,CAACT,WAAD,EAAc;AACf,UAAM;AACJnC,MAAAA,QADI;AAEJ8D,MAAAA;AAFI,QAGF,IAHJ;AAIA,UAAM;AACJvD,MAAAA;AADI,QAEF4B,WAAW,CAAC7B,IAFhB;AAGA,UAAMoC,IAAI,GAAG,KAAKA,IAAL,CAAUP,WAAV,CAAb;AACA,QAAIZ,MAAJ;;AAEA,QAAIvB,QAAJ,EAAc;AACZ,UAAI+D,YAAJ;;AAEAxC,MAAAA,MAAM,GAAG,CAACwC,YAAY,GAAGD,WAAW,EAA3B,KAAkC,IAAlC,GAAyCC,YAAzC,GAAwDtE,gBAAgB,CAACD,UAAU,CAAC,UAAD,CAAX,EAAyBA,UAAU,CAAC,WAAD,CAAnC,CAAjF;AACD,KAJD,MAIO;AACL,UAAIwE,aAAJ;;AAEAzC,MAAAA,MAAM,GAAG9B,gBAAgB,CAAC,CAACuE,aAAa,GAAGF,WAAW,EAA5B,KAAmC,IAAnC,GAA0CE,aAA1C,GAA0DxE,UAAU,CAAC,QAAD,CAArE,EAAiFA,UAAU,CAAC,WAAD,CAA3F,CAAzB;AACD;;AAED,WAAOC,gBAAgB,CAAC8B,MAAD,EAASmB,IAAT,EAAenC,QAAf,CAAvB;AACD,GAnCmD;;AAqCpDkC,EAAAA,GAAG,CAACN,WAAD,EAAczD,KAAd,EAAqB;AACtB,UAAM;AACJ6B,MAAAA;AADI,QAEF4B,WAAW,CAAC7B,IAFhB;AAGA,UAAMoC,IAAI,GAAG,KAAKA,IAAL,CAAUP,WAAV,CAAb;AACA,WAAO/C,oBAAoB,CAAC,GAAD,EAAMK,gBAAgB,CAACI,cAAc,EAAf,EAAmB6C,IAAnB,EAAyBnC,QAAzB,CAAtB,EAA0D7B,KAA1D,CAA3B;AACD,GA3CmD;;AA6CpD6E,EAAAA,cAAc,CAACpB,WAAD,EAAc;AAC1B,UAAM;AACJ5B,MAAAA;AADI,QAEF4B,WAAW,CAAC7B,IAFhB;AAGA,UAAMoC,IAAI,GAAG,KAAKA,IAAL,CAAUP,WAAV,CAAb;AACA,WAAO1C,gBAAgB,CAACI,cAAc,EAAf,EAAmB6C,IAAnB,EAAyBnC,QAAzB,CAAvB;AACD,GAnDmD;;AAqDpDkD,EAAAA,IAAI,CAACtB,WAAD,EAAcuB,IAAd,EAAoB;AACtB,WAAO,CAAC,GAAGzE,6BAA6B,CAACL,OAAlC,EAA2C,KAAKgE,GAAL,CAAST,WAAT,CAA3C,EAAkEtC,cAAc,EAAhF,EAAoF6D,IAApF,EAA0F,KAA1F,CAAP;AACD,GAvDmD;;AAyDpDC,EAAAA,YAAY,CAACxB,WAAD,EAAcuB,IAAd,EAAoB;AAC9B,WAAO,CAAC,GAAGzE,6BAA6B,CAACL,OAAlC,EAA2C,KAAKgE,GAAL,CAAST,WAAT,CAA3C,EAAkEtC,cAAc,EAAhF,EAAoF6D,IAApF,EAA0F,IAA1F,CAAP;AACD;;AA3DmD,CAAhC,CAAtB;;AA+DA,MAAMO,aAAN,CAAoB;AAClBC,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChB,QAAIC,mBAAJ;;AAEA,UAAM/D,IAAI,GAAG8D,IAAI,CAACE,UAAlB;AACA,SAAKA,UAAL,GAAkBhE,IAAlB;AACA,SAAK8C,oBAAL,GAA4B9C,IAAI,CAACiE,aAAL,CAAmB;AAC7CC,MAAAA,IAAI,EAAE;AADuC,KAAnB,KAEtB,CAAC,CAACJ,IAAI,CAACK,QAFb;AAGA,SAAKxE,QAAL,GAAgBK,IAAI,CAACoE,cAAL,MAAyBpE,IAAI,CAACC,IAAL,CAAUoE,MAAnC,KAA8CrE,IAAI,CAACsE,aAAL,IAAsB,IAAtB,GAA6B,KAAK,CAAlC,GAAsCtE,IAAI,CAACsE,aAAL,EAApF,CAAhB;AACA,SAAKzE,eAAL,GAAuBG,IAAI,CAACuE,SAAL,MAAoBvE,IAAI,CAACS,QAAL,EAA3C;AACA,SAAKb,IAAL,GAAYkE,IAAI,CAAClE,IAAjB;AACA,SAAK4E,aAAL,GAAqB,CAACT,mBAAmB,GAAGD,IAAI,CAACU,aAA5B,KAA8C,IAA9C,GAAqDT,mBAArD,GAA2ED,IAAI,CAACW,OAArG;AACA,SAAKX,IAAL,GAAYA,IAAZ;AACD;;AAEDlB,EAAAA,YAAY,GAAG;AACb,WAAO1D,SAAS,CAAC,KAAK4E,IAAL,CAAUpE,SAAV,IAAuB,KAAKoE,IAAL,CAAUlB,YAAV,EAAxB,CAAhB;AACD;;AAEDa,EAAAA,WAAW,GAAG;AACZ,QAAI,KAAKK,IAAL,CAAUK,QAAd,EAAwB,OAAOjF,SAAS,CAAC,KAAK4E,IAAL,CAAUK,QAAX,CAAhB;AACxB,QAAI,KAAKL,IAAL,CAAUL,WAAd,EAA2B,OAAOvE,SAAS,CAAC,KAAK4E,IAAL,CAAUL,WAAV,EAAD,CAAhB;AAC5B;;AAEDiB,EAAAA,OAAO,GAAG;AACR,QAAI,KAAKZ,IAAL,CAAUa,aAAd,EAA6B;AAC3B,WAAKX,UAAL,CAAgBY,QAAhB,CAAyBxD,2BAAzB,EAAsD;AACpDE,QAAAA,OAAO,EAAE,KAAKwC,IAAL,CAAUa,aAAV,CAAwBjD;AADmB,OAAtD;AAGD;;AAED,UAAMmD,OAAO,GAAG,KAAKL,aAAL,GAAqBjB,aAArB,GAAqC3B,YAArD;AACA,KAAC,GAAGjD,kCAAkC,CAACJ,OAAvC,EAAgD,KAAKyF,UAArD,EAAiErD,OAAjE,EAA0EzC,MAAM,CAACsF,MAAP,CAAc;AACtF5D,MAAAA,IAAI,EAAE,KAAKA,IAD2E;AAEtF4B,MAAAA,KAAK,EAAE,KAAKwC,UAAL,CAAgBxC,KAF+D;AAGtFsB,MAAAA,oBAAoB,EAAE,KAAKA,oBAH2D;AAItFnD,MAAAA,QAAQ,EAAE,KAAKA,QAJuE;AAKtFE,MAAAA,eAAe,EAAE,KAAKA,eALgE;AAMtF+C,MAAAA,YAAY,EAAE,KAAKA,YAAL,CAAkBkC,IAAlB,CAAuB,IAAvB,CANwE;AAOtFrB,MAAAA,WAAW,EAAE,KAAKA,WAAL,CAAiBqB,IAAjB,CAAsB,IAAtB,CAPyE;AAQtFC,MAAAA,QAAQ,EAAEF,OAAO,CAACtC;AARoE,KAAd,EASvEsC,OATuE,CAA1E;AAUD;;AA3CiB;;AA+CpBzG,OAAO,CAACG,OAAR,GAAkBqF,aAAlB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.skipAllButComputedKey = skipAllButComputedKey;\nexports.default = exports.environmentVisitor = void 0;\n\nvar _traverse = require(\"@babel/traverse\");\n\nvar _helperMemberExpressionToFunctions = require(\"@babel/helper-member-expression-to-functions\");\n\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS,\n  assignmentExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  staticBlock,\n  stringLiteral,\n  thisExpression\n} = _t;\n\nfunction getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {\n  objectRef = cloneNode(objectRef);\n  const targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier(\"prototype\"));\n  return callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nfunction skipAllButComputedKey(path) {\n  if (!path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}\n\nconst environmentVisitor = {\n  [`${staticBlock ? \"StaticBlock|\" : \"\"}ClassPrivateProperty|TypeAnnotation`](path) {\n    path.skip();\n  },\n\n  Function(path) {\n    if (path.isMethod()) return;\n    if (path.isArrowFunctionExpression()) return;\n    path.skip();\n  },\n\n  \"Method|ClassProperty\"(path) {\n    skipAllButComputedKey(path);\n  }\n\n};\nexports.environmentVisitor = environmentVisitor;\n\nconst visitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Super(path, state) {\n    const {\n      node,\n      parentPath\n    } = path;\n    if (!parentPath.isMemberExpression({\n      object: node\n    })) return;\n    state.handle(parentPath);\n  }\n\n}]);\n\nconst unshadowSuperBindingVisitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Scopable(path, {\n    refName\n  }) {\n    const binding = path.scope.getOwnBinding(refName);\n\n    if (binding && binding.identifier.name === refName) {\n      path.scope.rename(refName);\n    }\n  }\n\n}]);\n\nconst specHandlers = {\n  memoise(superMember, count) {\n    const {\n      scope,\n      node\n    } = superMember;\n    const {\n      computed,\n      property\n    } = node;\n\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(superMember) {\n    const {\n      computed,\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return cloneNode(property);\n    }\n\n    return stringLiteral(property.name);\n  },\n\n  get(superMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n\n  _get(superMember, thisRefs) {\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return callExpression(this.file.addHelper(\"get\"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs.this]);\n  },\n\n  _getThisRefs() {\n    if (!this.isDerivedConstructor) {\n      return {\n        this: thisExpression()\n      };\n    }\n\n    const thisRef = this.scope.generateDeclaredUidIdentifier(\"thisSuper\");\n    return {\n      memo: assignmentExpression(\"=\", thisRef, thisExpression()),\n      this: cloneNode(thisRef)\n    };\n  },\n\n  set(superMember, value) {\n    const thisRefs = this._getThisRefs();\n\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return callExpression(this.file.addHelper(\"set\"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs.this, booleanLiteral(superMember.isInStrictMode())]);\n  },\n\n  destructureSet(superMember) {\n    throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);\n  },\n\n  call(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, true);\n  }\n\n};\nconst looseHandlers = Object.assign({}, specHandlers, {\n  prop(superMember) {\n    const {\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    return cloneNode(property);\n  },\n\n  get(superMember) {\n    const {\n      isStatic,\n      getSuperRef\n    } = this;\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    let object;\n\n    if (isStatic) {\n      var _getSuperRef;\n\n      object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier(\"Function\"), identifier(\"prototype\"));\n    } else {\n      var _getSuperRef2;\n\n      object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier(\"Object\"), identifier(\"prototype\"));\n    }\n\n    return memberExpression(object, prop, computed);\n  },\n\n  set(superMember, value) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return assignmentExpression(\"=\", memberExpression(thisExpression(), prop, computed), value);\n  },\n\n  destructureSet(superMember) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return memberExpression(thisExpression(), prop, computed);\n  },\n\n  call(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, true);\n  }\n\n});\n\nclass ReplaceSupers {\n  constructor(opts) {\n    var _opts$constantSuper;\n\n    const path = opts.methodPath;\n    this.methodPath = path;\n    this.isDerivedConstructor = path.isClassMethod({\n      kind: \"constructor\"\n    }) && !!opts.superRef;\n    this.isStatic = path.isObjectMethod() || path.node.static || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n    this.file = opts.file;\n    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;\n    this.opts = opts;\n  }\n\n  getObjectRef() {\n    return cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n\n  getSuperRef() {\n    if (this.opts.superRef) return cloneNode(this.opts.superRef);\n    if (this.opts.getSuperRef) return cloneNode(this.opts.getSuperRef());\n  }\n\n  replace() {\n    if (this.opts.refToPreserve) {\n      this.methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name\n      });\n    }\n\n    const handler = this.constantSuper ? looseHandlers : specHandlers;\n    (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      getSuperRef: this.getSuperRef.bind(this),\n      boundGet: handler.get\n    }, handler));\n  }\n\n}\n\nexports.default = ReplaceSupers;"]},"metadata":{},"sourceType":"script"}